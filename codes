#!/usr/bin/python3.5
from __future__ import division , print_function
import pandas as pd
import numpy as np

def enhanced_gini(model_score,labels,wgt,data):
    df=pd.DataFrame()
    df['prob']=data[model_score]
    df['default']=data[labels]
    df['wgt']=data[wgt]
    df=df.groupby('prob').agg({'default':'sum','wgt':'sum'}).reset_index()
    df.rename(columns={'default':'n_defaulters','wgt':'total_custs'},inplace=True)
    df.sort_values(by='prob',ascending=False,inplace=True)
    df['cum_capture']=df.n_defaulters.cumsum()/df.n_defaulters.sum()
    df['cum_custs']=df.total_custs.cumsum()
    df['wizard_line']=np.clip(df.cum_custs/sum(df.n_defaulters),0,1)
    df['bucket_width']=df['total_custs']/df.total_custs.sum()
    df['lag_capture']=df.cum_capture.shift(1)
    df.lag_capture.replace(np.nan,0,inplace=True)
    df['gini_model']=.5*(df.cum_capture+df.lag_capture)*df.bucket_width
    df['lag_wizard']=df.wizard_line.shift(1)
    df.lag_wizard.replace(np.nan,0,inplace=True)
    df['gini_wizard']=.5*(df.wizard_line+df.lag_wizard)*df.bucket_width
    enhanced_gini=abs((sum(df.gini_model)-.5)/(sum(df.gini_wizard)-.5))
    return df,enhanced_gini

def old_gini(target,score,wgt,bins, data, pctl):
	tscore = data[score]
	y_test = data[target]
	y_wgt = data[wgt]
	gini_df = pd.DataFrame({'tresp':y_test,'tscore':tscore,'t':y_wgt})
	gini_df = gini_df.sort_values('tscore', ascending=False)
	gini_df['cwgt']=gini_df['t'].cumsum()
	gini_df['twscore']=gini_df['tscore']*gini_df['t']
	bin = np.linspace(1,sum(gini_df.t),bins+1)
	bin = np.round_(bin, decimals=0, out=None)
	bin_dis=gini_df[['tresp']].groupby(pd.cut(gini_df.cwgt, bin,include_lowest=True)).sum()
	bin_score=gini_df[['twscore']].groupby(pd.cut(gini_df.cwgt, bin,include_lowest=True)).sum()
	bin_dis_nobs=gini_df[['t']].groupby(pd.cut(gini_df.cwgt, bin,include_lowest=True)).sum()
	lorenz = pd.merge(bin_dis, bin_dis_nobs, right_index=True,left_index=True)
	lorenz = pd.merge(lorenz, bin_score, right_index=True,left_index=True)
	lorenz['ct']=lorenz['t'].cumsum()
	lorenz['ctresp']=lorenz['tresp'].cumsum()
	lorenz['avgresp']=lorenz['tresp']/lorenz['t']
	lorenz['avgscr']=lorenz['twscore']/lorenz['t']
	lorenz['accuracy_abs']=abs(lorenz['avgresp']-lorenz['avgscr'])
	lorenz['random_line'] = np.linspace(1.0/bins, 1, bins)
	lorenz['wizard_line']=np.clip(lorenz['ct']/sum(lorenz.tresp),0,1)
	lorenz['cresppct']=lorenz['ctresp']/sum(lorenz.tresp)
	lorenz['gini_wizard']=lorenz['wizard_line']-lorenz['random_line']
	lorenz['gini_model']=lorenz['cresppct']-lorenz['random_line']
	gini = abs(sum(lorenz.gini_model)/sum(lorenz.gini_wizard))
	lorenz.reset_index(drop=True, inplace=True)
	return lorenz, gini, lorenz.loc[pctl-1, 'cresppct']

if __name__ == "__main__":
	data =pd.read_csv('/axp/rim/mldsml/dev/shubhi/ics_rnn/new_rnn/scored_v3_model_chg_only.csv', header=None, sep=" ", names=['key','rnn','def_ind'])
	data['wgt'] = 1
	bins = 100
	pctl = 2
	lorenz,gini_enhanced=enhanced_gini('rnn','def_ind','wgt',data)
	lorentz,gini,pctl = old_gini('def_ind','rnn','wgt',bins, data, pctl)
	print(gini_enhanced)
	print(pctl)




### AD

def accuracy(actual, predicted):
    preds = pd.DataFrame()
    preds['actual'] = actual
    preds['predicted'] = predicted
    acc = OrderedDict()
    acc['[0-0.01)'] = preds.loc[preds['predicted']<0.01, 'actual'].mean()
    acc['[0.01-0.02)'] = preds.loc[((preds['predicted']>=0.01) & (preds['predicted']<0.02)), 'actual'].mean()
    acc['[0.02-0.05)'] = preds.loc[((preds['predicted']>=0.02) & (preds['predicted']<0.05)), 'actual'].mean()
    acc['[0.05-0.1)'] = preds.loc[((preds['predicted']>=0.05) & (preds['predicted']<0.1)), 'actual'].mean()
    acc['[0.1-0.15)'] = preds.loc[((preds['predicted']>=0.1) & (preds['predicted']<0.15)), 'actual'].mean()
    acc['[0.15-0.2)'] = preds.loc[((preds['predicted']>=0.15) & (preds['predicted']<0.2)), 'actual'].mean()
    acc['[0.2-0.3)'] = preds.loc[((preds['predicted']>=0.2) & (preds['predicted']<0.3)), 'actual'].mean()
    acc['[0.3-0.5)'] = preds.loc[((preds['predicted']>=0.3) & (preds['predicted']<0.5)), 'actual'].mean()
    acc['[0.5-1.0)'] = preds.loc[preds['predicted']>=0.5, 'actual'].mean()
    return acc

def accuracy_deviation(actual, predicted):
    preds = pd.DataFrame()
    preds['actual'] = actual
    preds['predicted'] = predicted
    avg_rate = preds['actual'].mean()
    lower = preds['predicted'].min()
    cum_dev = 0.0
    for i in range(1, 11):
        q = 0.1*i
        upper = preds['predicted'].quantile(q)
        predq = preds.loc[((preds['predicted']>=lower) & (preds['predicted']<=upper)), 'predicted'].mean()
        actualq = preds.loc[((preds['predicted']>=lower) & (preds['predicted']<=upper)), 'actual'].mean()
        #print(predq, actualq, len(preds.loc[((preds['predicted']>=lower) & (preds['predicted']<=upper))]))
        cum_dev += np.abs(predq - actualq)
        lower = upper
    return cum_dev/(10*avg_rate)
